# StampFlow-11E_cpu

## 项目简介

这是一个基于创新"章机制"的RISC风格CPU设计，参考部分五级流水线架构，支持无依赖指令插队代替nop实现高速度，项目目前处于开发阶段。

他有8级流水线，11级发射，5个执行器：alu fpu imm jump mov

暂未设计分支预测系统以及部分指令（后面打斜杠或者写着废除的指令）

可能存在bug

### 核心特性

- **创新章机制**：通过盖章标记指令执行状态，实现精细化的流水线控制
- **五级流水线**：取指(F)、译码(D)、执行(E)、访存(M)、写回(W) 单个指令会严格按照EMW的顺序写，但是整体允许插队
- **插队机制**：支持指令插队绕过
- **多执行单元**：ALU、FPU、跳转、移动、立即数处理等
- **资源冲突解决**：老人优先原则，避免数据冒险

### 架构示意
取指(PC+IM) → 译码(ID) → 传送带调度
                        ↓       ↑
                    （可运行指令）（写回寄存器位置和章）：执行器：执行访存写回

## 流水线描述
首先他分为取指，译码，执行，访存，写回五条结构

首先是取指，译码了之后把指令分为几个部分，执行的内容，访问的资源，以及预留三位代表三个章，三个章分别表示该条指令的执行情况执行，访存，写回这几个步骤完成了哪些，开头译码部分先检查指令不需要哪些部分提前先盖章相关的位数放入一个类似传送带的寄存器中
一条指令每个tick都会检查哪些地区空闲，前面是否有同性质的指令，前面是否有未执行完的依赖项

译码阶段就是把码翻译成执行号，访问资源，等等就是拆散便于执行

一条指令要想执行先检测前面有没有需要依赖项避免执行错误，前面有没有需要同类型的运算避免资源抢夺，以及相关执行器是否空闲，如果全部满足就送入执行器执行执行器变为1代表非空闲，并在相对应的位置盖章代表已被执行某个部分，如果出现两个执行器都空闲，单条指令都需要执行，那就先执行访存命令，如果指令前面有因为依赖项暂时没执行的命令则允许绕过他执行命令，具体就是增加一位判断他是否可执行，可执行就跳过

检测未写回就是检测该条指令需要访问的寄存器有没有被写回到内存里，如果没有就是没写回，执行运算的指令也是，检测前面未能够执行的指令中有没有和要执行的指令寄存器冲突的，如果有，那就等前面的执行完

还有运算指令也是如果检测到前面的值没有写回到内存就不要碰哪个寄存器，但是可以取他的值进行运算

*//命令锁链只向运算器输出哪些命令可用，实际选择要由运算器决定


只要把所有参与计算的寄存器保护起来，通过增多寄存器数量以及编译器的优化来实现，来避免出现资源被覆盖的情况

如果一条指令进入流水线后检测前面有无依赖项，比如未写回的内容，未访存的内容，未计算的内容，以及是否有执行器空闲，执行这条指令是否需要先后顺序，然后检测前面是否有需要同性质的计算，保持老人优先原则


### 主要模块

- **`top`**: 顶层集成模块
- **`pc_adder`**: PC计算和跳转控制
- **`inst_mem`**: 指令存储器
- **`if_id`**: 取指-译码阶段
- **`conveyor`**: 传送带指令调度器
- **`pool`**: 章和取信号汇集器
- **`reg_file`**: 寄存器堆(11读8写端口)
- **`alu`/`fpu`/`jump`/`mov`/`imm`**: 各功能执行单元

### 环境要求

- Verilog仿真器
- Verilog编译器
