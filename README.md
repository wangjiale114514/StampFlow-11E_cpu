# StampFlow-11E_cpu

## 项目简介

这是一个基于创新"章机制"的RISC风格CPU设计，参考部分五级流水线架构，支持无依赖指令插队代替nop实现高速度，项目目前处于开发阶段。

他有8级流水线，11级发射，5个执行器：alu fpu imm jump mov

暂未设计分支预测系统以及部分指令（后面打斜杠或者写着废除的指令）

可能存在bug

## 核心特性

- **创新章机制**：通过盖章标记指令执行状态，实现精细化的流水线控制
- **五级流水线**：取指(F)、译码(D)、执行(E)、访存(M)、写回(W) 单个指令会严格按照EMW的顺序写，但是整体允许插队
- **插队机制**：支持指令插队绕过
- **多执行单元**：ALU、FPU、跳转、移动、立即数处理等
- **资源冲突解决**：老人优先原则，避免数据冒险

## 架构示意
- 取指(PC+IM) → 译码(ID) → 传送带调度
-                         ↓       ↑
-                     （可运行指令）（写回寄存器位置和章）：执行器：执行访存写回

## 流水线描述
首先他分为取指，译码，执行，访存，写回五条结构

首先是取指，译码了之后把指令分为几个部分，执行的内容，访问的资源，以及预留三位代表三个章，三个章分别表示该条指令的执行情况执行，访存，写回这几个步骤完成了哪些，开头译码部分先检查指令不需要哪些部分提前先盖章相关的位数放入一个类似传送带的寄存器中
一条指令每个tick都会检查哪些地区空闲，前面是否有同性质的指令，前面是否有未执行完的依赖项

译码阶段就是把码翻译成执行号，访问资源，等等就是拆散便于执行

一条指令要想执行先检测前面有没有需要依赖项避免执行错误，前面有没有需要同类型的运算避免资源抢夺，以及相关执行器是否空闲，如果全部满足就送入执行器执行执行器变为1代表非空闲，并在相对应的位置盖章代表已被执行某个部分，如果出现两个执行器都空闲，单条指令都需要执行，那就先执行访存命令，如果指令前面有因为依赖项暂时没执行的命令则允许绕过他执行命令，具体就是增加一位判断他是否可执行，可执行就跳过

检测未写回就是检测该条指令需要访问的寄存器有没有被写回到内存里，如果没有就是没写回，执行运算的指令也是，检测前面未能够执行的指令中有没有和要执行的指令寄存器冲突的，如果有，那就等前面的执行完

还有运算指令也是如果检测到前面的值没有写回到内存就不要碰哪个寄存器，但是可以取他的值进行运算

*//命令锁链只向运算器输出哪些命令可用，实际选择要由运算器决定


只要把所有参与计算的寄存器保护起来，通过增多寄存器数量以及编译器的优化来实现，来避免出现资源被覆盖的情况

如果一条指令进入流水线后检测前面有无依赖项，比如未写回的内容，未访存的内容，未计算的内容，以及是否有执行器空闲，执行这条指令是否需要先后顺序，然后检测前面是否有需要同性质的计算，保持老人优先原则

## 仿真讲解：
![这是我们要执行的指令](com.png)


## 主要模块

- **`top`**: 顶层集成模块
- **`pc_adder`**: PC计算和跳转控制
- **`inst_mem`**: 指令存储器
- **`if_id`**: 取指-译码阶段
- **`conveyor`**: 传送带指令调度器
- **`pool`**: 章和取信号汇集器
- **`reg_file`**: 寄存器堆(11读8写端口)
- **`alu`/`fpu`/`jump`/`mov`/`imm`**: 各功能执行单元

## 指令集
### 指令格式
- 31       26 25     21 20     16 15     11 10      0
- +----------+----------+----------+----------+----------+
- |   opcode |    rs    |    rt    |    rd    | 立即数/偏移量 |
- +----------+----------+----------+----------+----------+
-  6 bits     5 bits      5 bits     5 bits     11 bits
-  rs和rt统一为源寄存器rd为目标寄存器，除非一些特殊指令，指令结构严格按照rs，tt，rd，立即数的顺序排列

-  所有寄存器组的寻址均为5位也就是32个通用寄存器，对应真实的指令格式

  
### 指令集以及操作码(共35条指令)：

#### 运算指令：
- 加法：         000000 ADD rs, rt, rd;
- 减法：         000001 SUB rs, rt, rd;
- 与运算:        000010 AND rs, rt, rd;
- 或运算:        000011 OR  rs, rt, rd;
- 异或运算:      000100 XOR rs, rt, rd;
- 小于置位:      000101 SLT rs, rt, rd;

#### 立即数指令：
- 立即数加法:    000110 ADDI rs, rd, imm;
- 立即数与:      000111 ANDI rs, rd, imm;
- 立即数或:      001000 ORI  rs, rd, imm;
- 加载高位立即数: 001001 LUI  rs, imm   ;

#### 访存指令：
- 加载字节:      001100 LB rs rd;  //rs为要要加载哪个地址的东西，rd是加载到寄存器什么地方
- 存储字节:      001101 SB rs rd;  //rs是存储到哪个地址，rd是存储的东西

#### 分支指令：
- 相等分支:      001110 BEQ rs, rt, rd;  //rd为跳转偏移量
- 不等分支：     001111 BNE rs, rt, rd;  
- 小于等于零分支:010000 BLEZ rs, rd;
- 大于零分支:    010001 BGTZ rs, rd;

#### 跳转指令:
- 直接跳转:      010010 J    rs;         //rs为跳转偏移量
- 跳转并链接：   010011 JAL  rs rd;      //rd为要存储跳转之后的地址

#### 位移指令：
- 逻辑左移：     010110 SLL  rs, rt, rd;  
- 逻辑右移:      010111 SRL  rs, rt, rd;
- 算术右移:      011000 SRA  rs, rt, rd;
- 算术左移:      011001 CNM  rs, rt, sd;

#### 乘除法：
- 乘法：         011110 MULT rs, rt, rd;
- 除法:          011111 DIV  rs, rt, rd;

#### 浮点数运算:
- 浮点数加法:    100000 FADD  rs, rt, rd;
- 浮点数减法:    100001 FSUB  rs, rt, rd;
- 浮点数乘法:    100010 FMULT rs, rt, rd;
- 浮点数除法：   100011 FDIV  rs, rt, rd;
- 浮点数比较大于:100100 FUCK  rs, rt, rd;    //比较指令会根据结果填rd的值，如果为真则全为1，如果为假则全为0
- 浮点数比较小于:100101 FKCU  rs, rt, rd;
- 浮点数比较等于:100110 FKCK  rs, rt, rd;
- 浮点数比较不等:100111 FKNK  rs, rt, rd;
- 浮点数平方运算:101000 FAND  rs, rd;

#### 一般指令：
- 移动：        101010 MOV rs, rd;
- 取反:         101100 NOT rs, rd;

## 环境要求

- Verilog仿真器
- Verilog编译器
- 可以使用modelsim


## 快速构建
- 第一步：创建项目目录结构
- 第二步：将所有.v文件复制到该文件夹
- 第三步：开一个新项目
- 第四步：把所有的.v文件添加进去并选择verilog
- 第五步：输入vlog *.v编译所有内容
- 第六步：simulate - start sim...仿真

## 更新日志

**`2025年11月14日`**
- 修复了编译上的一些报错
- 修复了一些位宽的报错
- 把break语句全部换成了begin : **  +  disable fpu_ex的形式
- 添加简易测试平台

**`2025年11月17日`**
- 修复了一些bug可以正常运行了
- 增加了测试平台测试数量，顶层互联层优化
- 添加整理指令集
- 优化代码逻辑
